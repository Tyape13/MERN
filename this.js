const thisObject = {
    name: "just nothing",
    wahteva: this,
    directFunction(){
        console.log("This is of directFunction():")
        console.log(`Printing this here will put a blue scope region in it's parents itself. ${this.name}`);
    },
    nothing: {
        arrowFuncHo: () => {
            console.log("this arrow function 'this' will look at area of scope above parents where it's declared");
            console.log(`This Should Print: ${this.name}`);
        }
    },
    testing:() =>{
        console.log("This is of ArrowFuncHo():")
        thisObject.nothing.arrowFuncHo(); // we an't put only arrowFuncHo(); we need whole complete address.
        console.log(`This shouldn't anything cause it looks where parents is declared and those region will be blue Area of Scope Vision`);
        console.log("this prints nothing cause: arrow func testing's parents is thisObject whose blue area is WINDOW");
        console.log("this is of testing():")
        console.log(`${this.name}`);
    }
}
// 1st and 2nd will print but not third one and
// {} this isn't dictionary but an Independent Object without Blueprint, 
// like in python, classes are blueprint and objects that are generated looks like COMMUNITY.
// but this is Independent random house generated by a man with his own knowledge and requirments.

thisObject.directFunction();
thisObject.testing(); // i thought it would work but
// testing doesn't even know arrowFuncHo Exists
// ok this didn't work. 


// as arrow function can't be considered a parent, neither will object literals be called a parent.
// but 'this' inside arrow function will look for scope of where parents are defined, just 1 step above parents is blue area.
// only normal functions that are PHYSICALLY Written as 'FUNCTION' keyword can only be Parents for arow function, not inbuild functions.
// so now the questions is when will these functions be good for which scenerios. i mean best practices to use arrow or normal, when? how?


// Your four summary points are essentially the "Secret Sauce" to mastering JavaScript. Let’s do a quick "Quality Check" on them and then lay out the Best Practices so you can stop guessing.
// Quality Check on your Concepts
// Arrow functions aren't parents: TRUE. They don't have their own this.
// Object literals aren't parents: TRUE. They are just data containers (Glass).
// Arrow this looks for the Blue Area of the parent: TRUE. Specifically, it looks for the nearest Brick House it was written inside of.
// Only function keywords are Brick Houses: TRUE. (Note: The shorthand methodName() {} you used in directFunction is also a Brick House. It’s just a shorter way of writing methodName: function() {}).

// simply vannu parda. 
// only 'function' lekhera baneko function or just shortform direct one 'functho(){}' can be Parent.
// {} can't be parent, arrow fucn can't be parents neither inbuild functions like setTimeout.
// so arrowfucntion passess right through them cause they can't be parents.
// arrow function ko 'this' will look one step above parents. 
// normal function ko 'this' will have blue area of Scope just where it's declared or called? idk about this one tho.
// Here is the distinction I already know:
// Scope (Variables): Is determined by where it is DECLARED. (Where it was born).
// this (Context): Is determined by how it is CALLED. (Who pulled the trigger).
// The Dot Rule: > If you see object.function(), then this is the object.
// If you see just function(), then this is the Global Window. True but noone uses 'this' in normal function declared outside.


const pomodoro = {
    minutes: 25,
    minute:0,
    
    // 1. ENTRY POINT: Regular Function (Brick)
    start() { 
        console.log(`Starting ${this.minutes} minute timer...`);

        // 2. CALLBACK: Arrow Function (Glass)
        // It stays connected to 'pomodoro' because it's inside start()
        const id = setInterval(() => {
            console.log(`${++this.minute} minutes are up!`);
            // ++this.minute; // if this code outside, minutes doesn't update rather it's 1 forever.
            if (this.minute == this.minutes){ // if this code outside, this would have executed before and when 25=25 it's too late.
            clearInterval(id);
        }
        }, 1000);
        
    }
};

pomodoro.start();


const user = {
    name: "Saurav",
    greet: function() { // BRICK HOUSE
        console.log("Normal func this:", this.name);
        
        const arrow = () => { // GLASS HOUSE
            console.log("Arrow func this:", this.name);
        };
        arrow();
    }
};

const outsider = user.greet; // Ripping the function out of the house
outsider();

// When we call outsider(), there is no dot.

// The "Normal function" this becomes Global/Window (because no one "called" it from an object).

// The "Arrow function" looks at its parent (greet). It says "I'll use whatever you're using!"

// Since greet is using Global, the Arrow also uses Global.

// Use Normal Function when...	                                Use Arrow Function when...
// You are creating a Method on an object (the entry point).	You are inside a method and using setTimeout or map.
// You are making a Constructor (Class-style).	                You are writing a short, one-line utility function.


// button.addEventListener('click', function() {
//     console.log(this); // This refers to the BUTTON you clicked.
// });

// button.addEventListener('click', () => {
//     console.log(this); // This refers to the WINDOW.
// });